<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" >
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport">
  <title>Content Negotiation by Profile</title>
  <link rel="stylesheet" type="text/css" href="extra.css">
</head>
<body class="h-entry" id="respecDocument">
  <section id="abstract">
    <h2>Abstract</h2>
    <p>
      This document describes how Internet clients may negotiate for content provided by servers according to
      <em>profiles</em>. This is distinct from negotiating by Media Type or Language: the <em>profile</em> is expected
      to specify the content of information returned, which may be a subset of the information the responding server has about the requested resource, and may be structured in a specific way to meet interoperability requirements of a community of practice.
    </p>
  </section>
  <section id="sotd">
    <!-- The "Status of This Document" section is generated by config.js -->
    <section id="FamilyOfDocs">
      <h3>Overview of DXWG documents on profiles</h3>
      <p>
        This document is part of a set of documents on profiles, edited by the W3C Dataset Exchange Working Group (DXWG). 
	      Some of the documents are general while some are technology-specific:
      </p>
      <ul>
        <li>[[PROF-GUIDANCE]] the top-level general recommendations and guidance on profiling.
          It gives an overview of all DXWG documents on profiles and is the recommended starting point</li>
        <li>[[PROF]] an RDF vocabulary that describes profiles and related resources</li>
        <li><strong>[PROF-CONNEG] this document, specific guidance on how to negotiate for Internet resource content using profiles</strong></li>
        <li>[[PROF-IETF]] an <a href="http://www.ietf.org">IETF</a> <a href="http://www.ietf.org/standards/ids/">Internet-Draft</a> defining HTTP Headers for HTTP content negotiation by profile</li>
      </ul>
    </section>
  </section>
  <section id="introduction" class="informative">
    <h1>Introduction</h1>
    <p>
      Content delivered by dereferencing Internet identifiers can be negotiated for in different
      ways. When using the HTTP protocol [[RFC7230]], a client may set one or more headers:
    </p>
    <ul>
      <li>an <code>Accept</code> header specifying preferred Media Types which the server may or may not supply</li>
      <li>an <code>Accept-Encoding</code> header to request that a specific content encoding system be used</li>
      <li>an <code>Accept-Language</code> header to indicate a preferred language</li>
    </ul>
    <p>
      However, clients have not had a
      defined way to negotiate for content based on its adherence to an information model - a standard, a specification or
      a <a>profile</a> - and this document addresses this functionality.
    </p>
    <p>
      When online information about a resource adheres to one or more profiles, methods described here allow
      clients to list those profiles and request content according to one or more of them in order of preference.
      For example, information about an online book might adhere to the Dublin Core Terms [[DCTERMS]] metadata
      specification with each field of information, such as <em>title</em>, <em>description</em>, <em>author</em> etc.,
      being defined and formatted according to various Dublin Core elements (<code>dct:title</code>,
      <code>dct:description</code> &amp; <code>dct:creator</code>, respectively). Then, a request for the information about this
      book may ask for the list of profiles according to which the metadata is available, or it may ask specifically for a response adhering to the
      Dublin Core Terms. When no profile or an unsupported profile is requested, a server returns default content, that
      is, content conforming to the default profile supported by the server.
    </p>
    <p>
      When selecting a content negotiation mechanism, an Internet client may use the HTTP protocol but it may also use
      other methods for providing instructions to a server,
      such as URI Query String Arguments (<abbr title="Query String Arguments">QSAs</abbr>).
      QSAs are
      established as useful for humans and machines for situations where negotiation via HTTP is not practical, such
      as when manually entering requests into web browsers. This document also provides guidance for both HTTP and non-HTTP methods
      of content negotiation and ensures they all adhere to a single functional specification, ensuring their functional equivalency.
    </p>
    <p>
      Guidance for the creation of <a>profile</a>s is provided in the [[PROF-GUIDANCE]] document created
      by the Dataset Exchange Working Group (DXWG).
    </p>
    <p>
      Describing the parts of profiles and their relation to other profiles is the function of the Profiles Vocabulary
      [[PROF]], also produced by the DXWG.
    </p>
  </section>
  <section id="conformance">
    <p>
      For the purpose of compliance, the normative sections of this document are
      <a href="#definitions">Section 3</a>,
      <a href="#abstractmodel">Section 6</a>,
      <a href="#realizations">Section 7</a> and
      <a href="#testsuites">Section 8</a>.
    </p>
  </section>
  <section id="definitions">
    <h2>Definitions</h2>
    <dl>
      <dt><dfn>specification</dfn></dt>
      <dd>
        <p>
          An act of identifying something precisely or of stating a precise requirement. - <a href="https://en.oxforddictionaries.com/definition/specification">Oxford English Dictionary</a>
        </p>
        <p>
          One form of a <em>specification</em> is a <em>standard</em> which is a "basis for comparison; a reference
          point against which other things can be evaluated" - [[DCTERMS]]
        </p>
      </dd>
      <dt><dfn>profile</dfn></dt>
      <dd>
        <p>
          A named set of constraints on one or more identified base <em>specifications</em>,
          including the identification of any implementing subclasses of datatypes,
          semantic interpretations, vocabularies, options and parameters of those base specifications
          necessary to accomplish a particular function.
        </p>
        <p>
          This definition includes what are often called "application profiles", "metadata application
          profiles", or "metadata profiles".
        </p>
        <p><em>Source: deliberations of the DXWG. See <a href="https://www.w3.org/2017/dxwg/wiki/ProfileContext">ProfileContext wiki page</a>.</em></p>
      </dd>
      <dt><dfn>client</dfn></dt>
      <dd>
        A program that establishes a connection to a server for the purpose of sending one or more HTTP requests
        [[RFC7230]]
      </dd>
      <dt><dfn>server</dfn></dt>
      <dd>
        A program that accepts connections in order to service HTTP requests by sending HTTP responses. [[RFC7230]]
      </dd>
      <dt><dfn>resource</dfn></dt>
      <dd>
        The entity that is identified by a URI. Familiar examples include an electronic
        document, an image, a source of information with a consistent purpose. [[RFC3986]]
      </dd>
      <dt><dfn>metadata</dfn></dt>
      <dd>Information that is supplied about a resource [[RFC3986]]</dd>
      <dt><dfn>request</dfn></dt>
      <dd>A message sent over the Internet, from a <em>client</em> to a <em>server</em>, for a information about a <em>resource</em> [[RFC7230]]</dd>
      <dt><dfn>response</dfn></dt>
      <dd>A message sent over the Internet, from a <em>server</em> to a <em>client</em> answering a <em>request</em> for information about a <em>resource</em> [[RFC7230]]</dd>
      <dt><dfn>token</dfn></dt>
      <dd>A short name identifying something, in the context of this document a <a>profile</a></dd>
    </dl>
  </section>
  <section id="motivation" class="informative">
    <h2>Motivation</h2>
    <p>
      In many cases, there are several ways to describe a resource within the scope of a single Media Type.
      For instance, XML documents, while conforming to the <code>text/xml</code> Media Type, may adhere to one of
      several DTDs or XML Schemas. RDF documents, with a choice of Media Type serializations such as
      <code>text/turtle</code>, <code>application/rdf+xml</code> and others, have a large number of vocabularies
      (classes and properties) available to use for their content's information model. When a client initiates a request
      for an Internet resource, such as an HTTP GET to retrieve a resource or an HTTP PUT to create or replace a resource, the client and server must have a standardized way to exchange information on how the transmitted resource
      will be structured according to DTDs, XML Schema, vocabularies or other standards, specifications or
      <em>profiles</em>. When using non-HTTP content negotiation, various methods such as URIs with Query String
      Arguments have been implemented previously,
      such as the
      <abbr title="Open Archives Initiative - Protocol for Metadata Harvesting">OAI-PMH</abbr> [[OAI-PMH]] and
      <abbr title="Open Geospatial Consortium">OGC</abbr>'s
      <abbr title="Catalogue Service for the Web">CSW</abbr> [[CSW]] protocols.
    </p>
    <p>
      This document describes content negotiation based on profiles using HTTP protocol. It introduces HTTP headers and
      non-HTTP methods, such as via QSAs, and defines a general QSA Application Programming Interface
      (<abbr title="Application Programming Interface">API</abbr>).
    </p>
  </section>
  <section id="relatedwork" class="informative">
    <h2>Related Work</h2>
    <p>
      The standardization of the content-negotiation HTTP headers is the purview of the IETF. A first proposal
      for an <a href="https://profilenegotiation.github.io/I-D-Accept--Schema/I-D-accept-schema">Internet Draft
      for Negotiating Profiles in HTTP</a> [[PROF-IETF]] is available but has not yet been submitted to the IETF. The
      current version of the IETF draft (-00) is expected to be completely re-written in parallel work with this document and should
      not be seen as anything but work-in-progress.
    </p>
	<section id="relatedwork-existingHttpStandards">
		<h3>Existing standards for transporting profile information in HTTP headers</h3>
	  <h4>Using Accept/Content Type together with the profile parameter</h4>
	  <p>The HTTP Accept and Content-Type header fields [[RFC 7231]]
		  allow a client to specify acceptable media types (<code>Accept</code>)
		  and a server to indicate the media type of the payload (<code>Content-Type</code>).
		  A media type registration can also specify an optional list of media type parameters.
		  Some media type registrations (e. g. <code>application/ld+json</code>)
		  have specified the use of a media type parameter named "profile"
		  that could be used to signal the profile the payload of the message conforms to.</p>
<pre class="example nohighlight" aria-busy="false" aria-live="polite" title="Using the profile parameter in an Accept header together with the Accept-Profile header">
GET /some/resource HTTP/1.1
Accept: text/turtle;q=0.9;profile="urn:example:profile-1",
	text/turtle;q=0.7;profile="urn:example:profile-2"

HTTP/1.1 200 OK
Content-Type: text/turtle;profile="urn:example:profile-2"
</pre>
    <p>During TPAC 2018 in Lyon, the DXWG had a longer discussion with the JSON-LD WG
	and it was concluded that the “profile” parameter in the <code>Accept</code> and <code>Content-Type</code>
	headers should be seen to convey profiles that are specific to the media-type,
	such as the JSON-LD profiles "expanded" (<code>http://www.w3.org/ns/json-ld#expanded</code>) or
	"flattened" (<code>http://www.w3.org/ns/json-ld#flattened</code>).
	In order to signal the use of media-type-independent profiles,
	the http header fields <code>Accept-Profile</code> and <code>Content-Profile</code> are to be used.</p>
    <h4>Using a Link-header with rel=”profile” (RFC 6906)</h4>
    <p>The HTTP Link header field [[RFC 8288]] relates a web resource (Link Context)
	to a target resource (Link Target
	by specifying the relation between the two resources.
	One of the relation types is “profile” as defined in [[RFC 6906]].
	    RFC 6906 <a href="https://tools.ietf.org/html/rfc6906#section-3">defines a profile</a> as
	    "additional semantics that can be used to process a resource representation […]
	    that do not alter the basic media type semantics,"
	    and specifically states that
	    "creators and users of profiles MAY define and manage them in a way
	    that allows them to be used across media types,"
	    so that the "profile" relation seems like a suitable way
	    to transport information about acceptable profiles (request) and payload profile (response).</p>
    <pre class="example nohighlight" aria-busy="false" aria-live="polite" title="Using a Link header with a profile parameter">
HEAD /some/other/resource HTTP/1.1
Accept: text/turtle;q=0.9,application/rdf+xml;q=0.5
Link: &lt;http://example.com/profile-1&gt;; rel="profile"

HTTP/1.1 200 OK
Content-type: text/turtle
Link: &lt;http://example.com/profile-1&gt;; rel="profile"
    </pre>
    <p>There is, however, no possibility to convey quality information (q-values) using the “profile” relation.</p>

    <h4>Using the Prefer/Preference-Applied header fields (RFC 7240)</h4>
    <p>The http <code>Prefer</code> and <code>Preference-Applied</code> header fields [[RFC 7240]]
    can be used to convey information about profile preferences.
    A client could use the <code>Prefer</code> header to tell the server about
    its preference for a payload conforming to a specific profile. 
    If the server sends a <code>Preference-Applied</code> header field in the response,
    the client will know that the preference was honoured.</p>
    <pre class="example nohighlight" aria-busy="false" aria-live="polite" title="Using a Link header with a profile parameter">
GET /some/resource HTTP/1.1
Accept: text/turtle
Prefer: profile="urn:example:schema"

HTTP/1.1 200 OK
Content-Type: text/turtle
Preference-Applied: profile="urn:example:schema"
    </pre>
	<p>This approach has two disadvantages.
		The first is - as with the <code>Link</code> header,
		that there is no possibility to work with q-values.
		The second one is that the only way for a server to state
		that it ignored the preference stated by the client
		is to omit sending a <code>Preference-Applied</code> header field.
		For the client - however - it is not clear
		if the <code>Preference-Applied</code> header is absent
		because the server did not honour the preference,
		or if it is because the server did not understand
		the <code>Prefer</code> header in the first place.
		This could be solved by making it mandatory to send a
		<code>Link: rel=profil</code> header when answering to a request
		with a <code>Prefer: profile=''</code> header in it. 
		That solution requires that a client evaluates two different headers
		in order to find a response to its request for a specific profile,
		which would make client implementation more complicated.</p>
	<p class="issue" data-number="380">
	    The Internet-Draft for the registration of
	    <code>Accept-Profile</code> and <code>Content-Profile</code>
	    is currently work-in progress.
	    When that work is completed, the above text will be adjusted accordingly
	    or deleted.
    </p>
    <p class="issue" data-number="382">
	    Previous uses of <code>Accept-*</code> headers
	    or other HTTP headers for this use
	    will be listed and discussed here.
    </p>
</section>
	  <section id="relatedWork-ark">
		  <h3>Archival Resource Key (ark)</h3>
		  <p>ARK (Archival Resource Key) [[ARK]] is an identifier scheme
			for the persistent identification of information objects.
			ARK identifiers can contain an optional qualifier 
			"that extends the base ARK in order to create a kind of service entry point
			into the object named by the NAA [sc. Name Assigning Authority]."
			Through a qualifier, any NMA (Name Mapping Authority, service provider offering ARK resolution)
			can supply access to variants of that object.
			The set of qualifiers is open and any ARK NAA or NMA can invent its own.
			The ARK specification lists versions, languages and formats as examples of qualifiers (§2.5)
			and a profile name could be used as a qualifier
			to refer to a representation of an information object conforming to that specific profile.
			E. g. does <a href="https://api.istex.fr/ark:/67375/6GQ-MLC8GRWC-5/">https://api.istex.fr/ark:/67375/6GQ-MLC8GRWC-5/</a>
			refer to different XML encodings of the metadata, one using MODS, the other one using other XML vocabularies.
		  </p>
	  </section>
    <div class="issue" data-number="383"></div>
    <div class="issue" data-number="516"></div>
    <div class="issue" data-number="384"></div>

  </section>
  <section id="abstractmodel">
    <h2>Abstract Model</h2>
    <p>
      This section describes an abstract conceptual model for content negotiation by profile, independent of any
      realizations of it within specific environments.
    </p>
    <section id="abstractmodelcontext">
      <h3>Context</h3>
      <p>
        All content negotiation takes place between a <a>client</a> and a <a>server</a> over the Internet with the
        former requesting a representation of a <a>resource</a> or a <em>resource</em>'s <em>metadata</em> through a
        <a>request</a> and receiving it via a <a>response</a>. In some cases, a <em>server</em> may have to make a
        <em>request</em> of a <em>client</em> and receive a <em>response</em>.
      </p>
      <p>
        An Internet <em>resource</em> may have many aspects over which a <em>client</em>/<em>server</em> pair of
        agents might negotiate for content. These aspects are to be treated independently so content negotiation for a 
        resource involving negotiation by profile and any other aspects of a resource will not affect
        each other. For this reason, other than a directive to maintain independence, no further discussion of 
        negotiation by profile and the relations to other forms of negotiation are given. Specific realizations might
        require special handling of profile and other forms of negotiation.
      </p>
      <p>
        A <em>client</em> <em>request</em>ing the representation of a <em>resource</em> conforming to a <em>profile</em>
        MUST identify the <em>resource</em> by a Uniform Resource Identifier (URI) [[RFC3986]] and MUST
        identify a <em>profile</em> either by a URI or a <em>token</em> that unambiguously identifies the
        <em>profile</em> for the <em>server</em> within that <em>request</em>/<em>response</em> session.
      </p>
      <p>
        In this abstract model, we don't assume any specifics about <em>client</em>, <em>server</em>, <em>resource</em>,
        <em>metadata</em>, <em>request</em> or <em>response</em>.
      </p>
      <p>
        If a URI is used for profile identification, it is recommended that it be an HTTP
        URI that dereferences to a description of the profile. Other kinds or URIs, e. g. URNs <em>MAY</em> also be used however
        systems will need to provide means to describe such profiles for a given URN. When a token is used, the
        server is responsible for declaring the context within which the token may be mapped to a unique profile
        identifier, such as an HTTP namespace.
      </p>
      <div data-number="690" class="issue"></div>
    </section>
    <section id="requestsandresonses">
      <h3>Requests and Responses</h3>
      <p>
        There are two main types of <em>request</em> that a <em>client</em> might make of a <em>server</em> regarding
        content negotiation by profile. A <em>client</em> wishing to negotiate for content via a profile adhering to this
        specification MUST be able to implement these two request types.</p>
      <ol>
        <li>
          <strong>list profiles</strong><br />
          a <em>client</em> requests the list of URIs of <em>profile</em>s for which a <em>server</em> is able to deliver
          conformant <em>resource</em>s
        </li>
        <li>
          <strong>get resource by profile</strong>
          <br />a <em>client</em> requests a representation of the requested <em>resource</em> represented conforming
          to a particular <em>profile</em>
        </li>
      </ol>
      <p>
        A <em>server</em> adhering to this specification MUST respond to each request with the following
        <em>response</em>s. 
      </p>
      <ol>
        <li>
          <strong>list profiles</strong><br />
          a <em>server</em> responds to a <em>client</em> with the list of <em>profile</em> URIs for the <em>profile</em>s for which it is able to
		deliver conformant <em>resource</em> representations 
        </li>
        <li>
          <strong>get resource by profile</strong><br />
          a <em>server</em> responds with either a specific <em>profile</em> for a <em>resource</em> conforming to a
          requested <em>profile</em> identified by the <em>client</em> or it responds with a default <em>profile</em>
        </li>
      </ol>
      <div class="issue" data-number="587"></div>
      <p>More detailed descriptions of these requests and their responses are given next.</p>
      <section id="listprofiles">
        <h4>list profiles</h4>
        <p>
          A <em>client</em> wishes to know for which <em>profile</em>s a <em>server</em> is able to deliver conformant
          representations of a <em>resource</em>. The content of the list can be known either before a <em>request</em> for a 
          particular <em>resource</em> representation is made or it is known after an initial <em>request</em> for a
          <em>resource</em> representation is made.
        </p>
        <p>
          The <strong>list profiles</strong> <em>request</em> MUST be either an independent request or part of another
          realization's request.
        </p>
        <p>
          The <strong>list profiles</strong> <em>request</em> MAY result in a <em>response</em> in one of a
          number of formats provided that the <em>profile</em>s representations of resources
          conform to are unambiguously identified either by URI or a <em>token</em> which MUST be mappable to a URI
          within one particular client/server session.
        </p>
        <p>
          A <em>server</em> MUST NOT list <em>profile</em>s that <em>resource</em> representations conform to if
          it is unable to deliver those representations when presented with a <strong>get resource by profile</strong>
          <em>request</em>.
        </p>
      </section>
      <section id="getresourcebyprofile">
        <h4>get resource by profile</h4>
        <p>
          The most basic <em>request</em> of content negotiation by profile is for a <em>client</em> to <em>request</em>
          a representation of a <em>resource</em> that is claimed to conform to a <em>profile</em>.
        </p>
        <p>
          A <em>client</em> executing a <strong>get resource by profile</strong> <em>request</em> MUST
          identify the <em>profile</em> with either a URI or a token mapping unambiguously within a session to a URI.
        </p>
        <p>
          A <em>client</em> executing a <strong>get resource by profile</strong> MAY <em>request</em> a
          <em>resource</em> representation conforming to one of any number of <em>profile</em>s with its preference
          expressed in a some form of list ordering.
        </p>
        <div class="issue" data-number="588"></div>
        <p>
          The server should attempt to reply with a profile that best matches the client request. The order of
          preference a server <em>MUST</em> follow to determine a best matching profile is: an exact match, followed by
          a profile (perhaps transitively) of the requested profile.
        </p>
        <p>
          If a client requests a profile but gets a narrower profile, the Server should set its responses
          Content-Profile header to the profile identifier that the Client requested, not the identifier of the
          narrower profile as the client might not understand the narrower profile identifier.
        </p>
        <pre class="example nohighlight" aria-busy="false" aria-live="polite" title="Get resource by profile, narrower profile response (HTTP realization)">
# a request for Resource 1 according to Profile A is made

GET http://example.org/resource/1 HTTP/1.1
Accept-Profile: http://example.org/profile/A
[more request headers]

---

# the server IS NOT able to respond with a representation
# of Resource 1 conforming to Profile A

# the server IS able to respond with a representation of
# Resource 1 according to Profile B which it knows is a
# profile of Profile A

# the server indicates the response conforms to Profile A,
# not Profile B so the client is assured of conformance

HTTP/1.1 200 OK
[other response headers]
Content-Profile: http://example.org/profile/A
[more response headers]

[content according to Profile B and thus Profile A which it profiles]
          </pre>
        <div class="issue" data-number="748"></div>
      </section>
    </section>
  </section>
  <section id="realizations">
    <h2>Realizations</h2>
    <p>
      This section describes <em>realization</em>s of the abstract model in multiple implementation domains.
    </p>
    <section id="http">
      <h3>Hypertext Transfer Protocol Headers</h3>
      <p>
        A realization of the Abstract Model using Hypertext Transfer Protocol (HTTP) headers is presented here.
        This implementation is based on HTTP content negotiation and uses two new HTTP headers,
	      <code>Accept-Profile</code> and <code>Content-Profile</code>
	      that are to be defined in an upcoming Internet-Draft [[PROF-IETF]].
      </p>
      <div class="issue" data-number="500"></div>
      <section id="listprofileshttp">
        <h3>list profiles</h3>
        <p>
          The preferred way to retrieve a list of profiles the server supports for a specific resource
	  is to issue a <code>GET</code> or <code>HEAD</code> request for that resource.
	  In either case, a server implementing
          content negotiation by profile SHOULD return an HTTP <code>Link</code> header containing information about the
          default representation of that resource and information about any alternate representations of that
          resource that that conform to potentially other profiles. The returned representation will be identified by <code>rel="self"</code>, other representations by
          <code>rel="alternate"</code>.
        </p>
        <p>As an example, consider the resource <code>http://example.org/a/resource</code> available
          in the Media Types <code>application/xml</code>, <code>text/html</code> and <code>text/turtle</code>.
          The <code>text/html</code> representation has
          no profile, whereas the <code>application/xml</code> and <code>text/turtle</code> representations are
          both available in the profiles <code>urn:example:profile:1</code> and <code>urn:example:profile:2</code>.
        </p>
        <p>
          All representations of <code>/a/resource</code> have Content-Location URLs. This results in the following matrix:
        </p>
        <table>
          <tr><th>Media Type / Profile</th><th>urn:example:profile:1</th><th>urn:example:profile:2</th></tr>
          <tr><th>text/html</th><td>http://example.org/a/resource.html</td><td>http://example.org/a/resource.html</td></tr>
          <tr><th>text/turtle</th><td>http://example.org/a/resource.prof1.ttl</td><td>http://example.org/a/resource.prof2.ttl</td></tr>
          <tr><th>application/xml</th><td>http://example.org/a/resource.prof1.xml</td><td>http://example.org/a/resource.prof2.xml</td></tr>
        </table>
        <p>
          Assuming that a request without an <code>Accept-Profile</code> header per default delivers content conforming to
          <code>urn:example:profile:1</code>, an HTTP request/response pair would look as follows:
        </p>
        <pre class="example nohighlight" aria-busy="false" aria-live="polite" title="Using a Link-header to point to a list of available profiles">
HEAD /a/resource HTTP/1.1
Accept: text/turtle
[more request headers]

---

HTTP/1.1 200 OK
Content-Type: text/turtle
Content-Location: http://example.org/a/resource.prof1.ttl
Content-Profile: urn:example:profile:1
Link: &lt;http://example.org/a/resource.prof1.ttl&gt;; rel="self"; type="text/turtle"; profile="urn:example:profile:1",
  &lt;http://example.org/a/resource.prof2.ttl&gt;; rel="alternate"; type="text/turtle"; profile="urn:example:profile:2",
  &lt;http://example.org/a/resource.prof1.xml&gt;; rel="alternate"; type="application/xml"; profile="urn:example:profile:1",
  &lt;http://example.org/a/resource.prof2.xml&gt;; rel="alternate"; type="application/xml"; profile="urn:example:profile:2",
  &lt;http://example.org/a/resource.html&gt;; rel="alternate"; type="text/html"
[more response headers]
        </pre>
        <section id="listprofiles-content">
          <h3>Optional response content</h3>
          <p>
            While the server SHOULD return the canonical list of profiles in the response's Link headers, it MAY also
            supply the list in response content and if it does so, content negotiation by Media Type CAN be used to request
            one of the following formats:
          </p>
          <dl>
            <dt>text/uri-list</dt>
            <dd>
              <p>
                A basic, unordered list of profile URIs to which representations of the resource conform - both the 'self'
                and 'alternate' profiles.
              </p>
              <p>
                Comment lines - lines starting with # - indicating 'self' and 'alternative' may be supplied above each URI
              </p>
            </dd>
            <dt>application/ld+json or <a href="https://www.w3.org/2001/sw/wiki/RDF">RDF data</a> serialized in any format</dt>
            <dd>
              <p>
                A serialization of profile information and resource/profile associations formalised using the Profiles
                Vocabulary [[PROF]].
              </p>
            </dd>
            <dt>text/html</dt>
            <dd>A human-readable version of Profiles Vocabulary content.</dd>
          </dl>
          <p>
            The example below shows the same information conveyed according to the three different response content Media
            Types listed above.
          </p>
          <pre class="example nohighlight" aria-busy="false" aria-live="polite" title="Different ways to include profiles information in response content">
# request for /a/resource

GET http://example.org/a/resource HTTP/1.1

---

# header response

HTTP/1.1 200 OK
Content-Type: text/turtle
Content-Location: http://example.org/a/resource.prof1.ttl
Content-Profile: urn:example:profile:1
Link: &lt;http://example.org/a/resource.prof1.ttl&gt;; rel="self"; type="text/turtle"; profile="urn:example:profile:1",
  &lt;http://example.org/a/resource.prof2.ttl&gt;; rel="alternate"; type="text/turtle"; profile="urn:example:profile:2",
  &lt;http://example.org/a/resource.prof1.xml&gt;; rel="alternate"; type="application/xml"; profile="urn:example:profile:1",
  &lt;http://example.org/a/resource.prof2.xml&gt;; rel="alternate"; type="application/xml"; profile="urn:example:profile:2",
  &lt;http://example.org/a/resource.html&gt;; rel="alternate"; type="text/html"
[more response headers]

# response content according to the text/uri-list Media Type, with comments

-
# self
urn:example:profile:1
# alternate
urn:example:profile:2
-

# response content according to the application/ld+json Media Type (JSON-LD)

-
{
  "@context": {
    "dct": "http://purl.org/dc/terms/",
    "prof": "http://www.w3.org/ns/dx/prof/",
    "rdfs": "http://www.w3.org/2000/01/rdf-schema#",
  },
  "@graph": [
    {
      "@id": "http://example.org/a/resource.prof2.xml",
      "dct:conformsTo": {
        "@id": "urn:example:profile:2"
      },
      "dct:format": {
        "@id": "https://w3id.org/mediatype/application/xml"
      },
      "rdfs:comment": "alternate"
    },
    {
      "@id": "http://example.org/a/resource.prof1.ttl",
      "dct:conformsTo": {
        "@id": "urn:example:profile:1"
      },
      "dct:format": {
        "@id": "https://w3id.org/mediatype/text/turtle"
      },
      "rdfs:comment": "self"
    },
    {
      "@id": "http://example.org/a/resource.prof2.ttl",
      "dct:conformsTo": {
        "@id": "urn:example:profile:2"
      },
      "dct:format": {
        "@id": "https://w3id.org/mediatype/text/turtle"
      },
      "rdfs:comment": "alternate"
    },
    {
      "@id": "http://example.org/a/resource.prof1.xml",
      "dct:conformsTo": {
        "@id": "urn:example:profile:1"
      },
      "dct:format": {
        "@id": "https://w3id.org/mediatype/application/xml"
      },
      "rdfs:comment": "alternate"
    }
  ]
}
-

# response content according to the text/html Media Type

-
&lt;html&gt;
  &lt;head&gt;[head information]&lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Alternative Profile information for Resource http://example.org/a/resource&lt;/h1&gt;
    &lt;table&gt;
      &lt;tr&gt;
          &lt;th&gt;Media Type / Profile&lt;/th&gt;
          &lt;th&gt;urn:example:profile:1&lt;/th&gt;
          &lt;th&gt;urn:example:profile:2&lt;/th&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;th&gt;text/html&lt;/th&gt;
          &lt;td&gt;http://example.org/a/resource.html&lt;/td&gt;
          &lt;td&gt;http://example.org/a/resource.html&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;th&gt;text/turtle&lt;/th&gt;
          &lt;td&gt;http://example.org/a/resource.prof1.ttl&lt;/td&gt;
          &lt;td&gt;http://example.org/a/resource.prof2.ttl&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;th&gt;application/xml&lt;/th&gt;
          &lt;td&gt;http://example.org/a/resource.prof1.xml&lt;/td&gt;
          &lt;td&gt;http://example.org/a/resource.prof2.xml&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/table&gt;
  &lt;/body&gt;
&lt;/html&gt;
-
          </pre>
        </section>
        <div class="issue" data-number="290"></div>
        <section id="listprofiles-tokens">
          <h3>Token mappings</h3>
          <p>
            If HTTP <em>server</em>s wish to allow <em>client</em>s to identify <em>profile</em>s via <em>token</em>,
            in addition to the the mandatory identification of <em>profile</em>s via via URI, the <em>server</em>s will
            need to provide a <em>token</em> / URI mapping via this <strong>list profiles</strong> function. In this
            HTTP realization, this may be implemented in a number of ways. The preferred way is to add "token"
            parameters to the HTTP Content-Profile and Link HTTP headers.
          </p>
          <pre class="example nohighlight" aria-busy="false" aria-live="polite" title="HTTP headers with profile URI / token mappings using 'token' parameters">
# The Profile with urn:example:profile:1 is mapped to token p1 and URI
# and the Profile with URI http://example.org/profile/2 is mapped to p2

HEAD /a/resource HTTP/1.1
Accept: text/turtle
[more request headers]

---

HTTP/1.1 200 OK
Content-Type: text/turtle
Content-Location: http://example.org/a/resource.prof1.ttl
Content-Profile: urn:example:profile:1;token=p1
Link: &lt;http://example.org/a/resource.prof1.ttl&gt;; rel="self"; type="text/turtle"; profile="urn:example:profile:1;token=p1",
  &lt;http://example.org/a/resource.prof2.ttl&gt;; rel="alternate"; type="text/turtle"; profile="http://example.org/profile/2;token=p2",
  &lt;http://example.org/a/resource.prof1.xml&gt;; rel="alternate"; type="application/xml"; profile="urn:example:profile:1;token=p1",
  &lt;http://example.org/a/resource.prof2.xml&gt;; rel="alternate"; type="application/xml"; profile="http://example.org/profile/2;token=p2",
  &lt;http://example.org/a/resource.html&gt;; rel="alternate"; type="text/html"
[more response headers]
          </pre>
          <div class="issue">
            Nick: I don't think <code>profile="urn:example:profile:1;token=p1"</code> will work within the Link header
            (too many layers of structured text) however I believe that where ever a profile URI is quoted, the token
            must be also thus it's necessary.
          </div>
          <div class="note" title="Multiple ways of conveying URI / token mappings">
            <p>
              There are several methods that many be used to convey URI / token mappings including the recommended
              method described and exemplified above.
            </p>
            <h4>Option 1: token parameters (recommended)</h4>
            <p>
              "token" parameters are added to <code>Content-Profile</code> &amp; <code>Link profile=</code> HTT headers.<br />
              Pros: self-contained,flexible, explicit.<br />
              Cons: potential redundancy in URIs if many offered
            </p>
            <h4>Option 2: registered tokens</h4>
            <p>
              Tokens are registered in a global registry and servers may use them in place of a URI<br />
              <code>Content-profile: token1, URI2</code>
              Pros: compact<br />
              Cons: a global registry for profiles not manageable when many systems define profiles and such a registry
              limits other capabilities of profile description by forcing generic profiles
            </p>
            <h4>Option 3: allow namespace declarations</h4>
            <p>
              As per the use of CURIEs [[CURIE]] whose specification "...defines a generic, abbreviated syntax for
              expressing URIs.", within JSON-LD [[JSON-LD]], a token may be indicated for use in place of a URI within
              a namespacing context. In this method, key/value pairs of tokens/URIs are defined within an HTTP header
              such as <code>Content-Profile</code> like this:
            </p>
            <p>
              <code>Content-Profile: @:http://example.org/profiles/,@w3c:http://w3.org/knownprofiles#, :token1, w3c:token2</code>
            </p>
            <p>
              Where the first key/value pair of token/URI is key: &lt;nothing&gt;, value: http://example.org/profiles/
              and the second, is key: &lt;w3c&gt;, value:http://w3.org/knownprofiles#.
            </p>
            <p>
              Pros: compact, no registry requirement<br />
              Cons: clients have more parsing to do<br />
              Note: could easily be a JSON-LD payload<br />
              (alternative syntax using parameter ns2;ns=http://example.org/profiles/)
            </p>
            <h4>Option 4: namespace header</h4>
            <p>
              In this method, a new HTTP header could be introduced to specifically convey token/URI profile key/value
              pairs. If <code>Content-Profile-Namespaces</code> is to be the new HTTP header, then a <em>server</em> may
              respond to a request with the following pair of headers:
            </p>
            <p>
              <code>
                Content-Profile-Namespaces: :http://example.org/profiles/,w3c:http://w3.org/knownprofiles#<br />
                Content-Profile: :token1, w3c:token2
              </code>
            </p>
          </div>
        </section>
        <div class="issue" data-number="679"></div>
      </section>
      <section id="getresourcebyprofilehttp">
        <h3>get resource by profile</h3>
        <p>
          	Getting a resource representation conforming to a specific profile is done
		by issuing an <code>HTTP GET</code> request against the resource
		and specifying the desired profile URI in an <code>Accept-Profile</code> header.
          	It is possible to specify a range of acceptable profile URIs
		and also to indicate preferences by using quality indicators (q-values).
        </p>
        <pre class="example nohighlight" aria-busy="false" aria-live="polite" title="Requesting a representation conforming to a specific profile using HTTP headers">
GET /a/resource HTTP/1.1
Accept: text/turtle;q=0.8, application/xml;q=0.5
Accept-Profile: urn:example:profile:1;q=1.0,urn:example:profile:2;q=0.6
[more request headers]

---

HTTP/1.1 200 OK
Content-Type: text/turtle
Content-Profile: urn:example:profile:1
[more response headers]
        </pre>
        <p>
          Having performed content negotiation and returned a resource representation, it is RECOMMENDED
          that the server also include a Link header indicating the availability of alternate resources
          encoded in other media types and conforming to other profiles, as described above.
        </p>
      </section>
    </section>
    <section id="qsa">
      <h2>URI Query String Arguments</h2>
        <p class="issue" data-number="544">
	  There is a question within the working group
	  regarding the advisability of specifying
	  an alternative method of content negotiation
	  conducted via query strings rather than HTTP headers.
	  We have a requirement to show how datasets with different profiles
	  can be made discoverable by humans, 
	  but there is disagreement whether this requirement
	  extends to implementing the same negotiation scheme
	  used in HTTP headers.
	</p>
	    <div class="issue" data-number="511"></div>
      <div class="issue" data-number="538"></div>
      <p>
	      A Query String Argument (QSA) realization of the <a href="#abstractmodel">Abstract Model</a>
	      is presented here. Unlike the HTTP realization,
 		which is the subject of an independent document [[PROF-IETF]],
	      this realization is fully specified here
	      and this document is considered normative for the QSA realization.
	      This realization does not preclude other QSA specifications for profile and content negotiation.
      </p>
      <p>
        A query string is a part of a URI which assigns values to specified parameters. QSAs are commonly used within
        web browsers by humans and in other <em>client</em>/<em>server</em> situations to deliver extra information to a
        <em>server</em>.
      </p>
      <p><strong><em>Key naming</em></strong></p>
      <p>
        When content negotiation by profile is to take place using QSAs, the <em>request</em>s and <em>response</em>s
        of the <a href="#abstractmodel">Abstract Model</a> MUST be implemented.
	      However there is some flexibility in how this may be done:
	      QSA key/value pairs must be implemented but the specific key terms may be changed.
	      In this realization, <code>_profile</code> and <code>_mediatype</code> are used
	      to indicate a single profile or a list of
        preference-ordered profiles or Media types respectively with profiles or Media Types indicated by either URI or
        token.
      </p>
      <div class="note" title="Current use of tokens for negotiation by Media Type">
        <p>
          Currently, the convention in HTTP content negotiation by media type uses tokens for Media Types, such as
          <code>text/html</code> or <code>application/ld+json</code> with the tokens registered at
          <a href="http://www.iana.org/assignments/media-types">IANA's Media Types list</a>.
        </p>
        <p>
          There is no proposal yet to create a central register of profiles as this is thought by the authors to be
          un-sustainable in the long-term, given the likely numbers of profiles to be established.
        </p>
        <p>
          For this reason, the QSA realization allows either URIs or tokens for profiles to be used and it is expected,
          though not mandated here, that QSA realizations will also allow URIs or tokens for Media Types and other
          content negotiation dimensions, such as language. There are already several initiatives that have created URIs
          for Media Types based on the IANA register's tokens.
        </p>
      </div>
      <p><strong><em>Resource URI</em></strong></p>
      <p>
        Resource URIs for which QSA-based profile negotiation is taking place MUST NOT themselves be QSA values
        of other resource URIs in any QSA-based realization. Such mechanics may be used but must be transparent to the
        realization's <em>client</em> applications.
      </p>
      <pre class="example nohighlight" aria-busy="false" aria-live="polite" title="Resource URIs must not, themselves, be parameters of other URIs">
For the representation of Resource X, according to Profile Y, in Media Type Z:

NOT ALLOWED:
GET /single/endpoint?resource=http://example.org/resource/X&amp;_profile=Y&amp;_mediatype=Z HTTP/1.1

ALLOWED:
GET /resource/X?_profile=Y&_mediatype=Z HTTP/1.1
      </pre>
      <section id="listprofilesqsa">
        <h4>list profiles</h4>
        <p>
          A QSA with a fixed value MUST be supported by a <em>server</em> to allow a <em>client</em> to
          make a <strong>list profiles</strong> <em>request</em>.
        </p>
        <div class="issue" data-number="589"></div>
        <p>
          The QSA key/value pair <code>_profile=list</code> SHOULD be used however the <em>server</em> MAY
          make available an equivalent pair as long as this is discoverable. This is to cater for APIs that alreadly
          implement a similar function using QSA key/value pairs such as <code>_view=alternates</code>.
        </p>
        <p>
          The complete request for the <em>profile</em>s to which a <em>resource</em>'s representations conform can be
          communicated in a single URI like thus:
        </p>
        <pre class="example nohighlight" aria-busy="false" aria-live="polite" title="Requesting a list of profiles for a resource by QSA">
GET /a/resource?_profile=list HTTP/1.1
        </pre>
        <!--
        <p><code>RESOURCE_URI?_profile=list</code></p>
        <p>where</p>
        -->
        <p>
          where <code>/a/resource</code> is the URI of the resource for which the list of available profiles is
          requested
        </p>
        <p>
          A <em>client</em> making this <em>request</em> MAY negotiate for particular formats of the response by
          using a QSA equivalent to the HTTP <code>Accept</code> header to indicate a Media Type. A <em>server</em>
          SHOULD implement a <code>_mediatype</code> QSA for this but MAY implement an alternative, such
          as <code>_format</code> as long as this is dicoverable,
        </p>
        <p>An example <em>profile</em> listing for a <em>resource</em> in HTML would look like:
        </p>
        <!--<p><code>RESOURCE_URI?_profile=list&_mediatype=text/html</code></p>-->
        <pre class="example nohighlight" aria-busy="false" aria-live="polite" title="Requesting a list of profiles for a resource by QSA in HTML">
GET /a/resource?_profile=list&amp;_mediatype=text/html HTTP/1.1
        </pre>
      </section>
      <section id="getresourcebyprofileqsa">
        <h4>get resource by profile</h4>
        <div class="issue" title="To be completed"></div>

        <p><strong><em>Expressing profile preference</em></strong></p>
        <p>
          A <em>server</em> implementing <em>profile</em> listing for <em>resource</em>s SHOULD allow the
          requester to indicate preferences. This SHOULD be done by allowing the QSA indicating the desired
          profile, usually <code>_profile</code>, to have a comma-separated list as its value so, for a
          <em>client</em> desiring representations of <code>/a/resource</code> according to profiles with tokens
          <code>aaa</code>, <code>bbb</code> &amp; <code>ccc</code> we have:
        </p>
        <pre class="example nohighlight" aria-busy="false" aria-live="polite" title="Requesting a list of profiles for a resource by QSA in HTML">
  GET /a/resource?_profile=aaa,bbb,ccc HTTP/1.1
        </pre>
        <p>
          Servers MAY support any combination of profile URIs or tokens for this
		(e.g. <code>aaa,http://example.org/profile-x,bbb</code>).
		However, in this situation, profile URIs containing commas must escape them.
        </p>
        <p>
          Similarly, a <em>server</em> implementing multiple Media Type return formats for <em>profile</em> listing SHOULD
          allow a client to specify a preference order for Media Types and also for other dimensions of content
          negotiation, such as language. When using a QSA-only API, Media Type preferences (and language and others in a
          similar fashion) MAY be specified in a comma-separated list form, most preferred to least such that
          a client requesting profil
        </p>
      </section>
    </section>
  </section>
  <section id="testsuites">
    <h2>Test Suites</h2>
    <p>
      This section includes links to software tools to be used for testing the adherence of implementations to the realizations
      given in this document.
    </p>
    <dl>
      <dt>Apache JMeter</dt>
      <dd>
        <p>
          An <a href="http://jmeter.apache.org/">Apache JMeter</a> implementation of a test suite is maintained at:
          <a href="https://github.com/CSIRO-enviro-informatics/prof-conneg-jmeter-test-suite">
            https://github.com/CSIRO-enviro-informatics/prof-conneg-jmeter-test-suite
          </a>
        </p>
      </dd>
    </dl>
    <div class="issue" data-number="385"></div>
  </section>
  <section id="implementations" class="informative">
    <h2>Implementations</h2>
    <p>
      This section includes implementations of the realizations given in this document and their conformance test results. The tools
      used for conformance testing are listed in the section above.
    </p>
    <ul>
      <li>
        <a href="https://github.com/CSIRO-enviro-informatics/prof-conneg-conf-test-results">
          https://github.com/CSIRO-enviro-informatics/prof-conneg-conf-test-results
        </a>
      </li>
    </ul>
    <div class="issue" data-number="467"></div>
  </section>
<section id="acknowledgements" class="informative">
	<h2>Acknowledgements</h2>
	<p>Comments and suggestions from
		Annette Greiner,
		Erik Wilde,
		Gregg Kellogg
		and Kam Hay Fung
		improved this specification
	</p>
</section>
<section id="changes" class="informative">
	<h2>Changes</h2>
	<p>Changes since the <a href="https://www.w3.org/TR/2018/WD-dx-prof-conneg-20181218/">18 December 2018 Working Draft</a> are:</p>
	<ul>
		<li>Added text about existing standards for transporting profile information in http headers
			to <a href="#relatedwork">related work</a>.
			(<a href="https://github.com/w3c/dxwg/issues/45">Issue 45</a>)</li>
		<li>Removed advice on use of HTTP OPTIONS.
			(<a href="https://github.com/w3c/dxwg/issues/510">Issue 510</a>)</li>
		<li>Added text about ARK identifiers to <a href="#relatedwork">related work</a>.
			(<a href="https://github.com/w3c/dxwg/issues/514">Issue 514</a>)</li>
		<li>Clarified difference between the <code>profile</code> parameter in <code>Accept</code> header fields
			and the <code>Accept-Profile</code> header field.
			(<a href="https://github.com/w3c/dxwg/issues/662">Issue 662</a>)</li>
		<li>Updated the <a href="#security_and_privacy">Security and Privacy</a> section.
			(<a href="https://github.com/w3c/dxwg/issues/782">Issue 782</a>)</li>
	</ul>
</section>
  <section id="security_and_privacy" class="informative">
    <h2>Security and Privacy</h2>
    <p>
      The use of HTTP to negotiate and transport implies that all privacy and security issues
      that are relevant for that protocol are also relevant for profile negotiation. E. g.,
      information such as user agent, accept-headers, IP address etc. can potentially be used as
      identifying information, and particularly, the IP address adds information about geolocation
      and institutional membership.
      Further, offering a list of acceptable profiles at the beginning of a negotiation process
      can reveal information about the user's interests
      that could be used to add such information to a user profile.
    </p>
    <p>
      For a more complete view of those issues, cf. the
      <a href="https://www.w3.org/2017/dxwg/wiki/CnegPrivacyAndSecurityQuestionnaire">Privacy and Security Questionnaire for this deliverable</a>.
    </p>
  </section>
  <section id="appendices" class="appendix">
    <h2>Appendices</h2>
    <section id="requirements">
      <h2>Requirements</h2>
      <p>
        This section lists, and then addresses, individual requirements that the Dataset Exchange Working Group
        considered important for content negotiation by profile.
      </p>
      <div class="note">
        <p>
          Responses to individual requirement Issues listed here are, at the time of the First Public Working Draft of
          this document, for demonstration only; to indicate the logic of answers to individual requirements.
        </p>
        <p>
          These requirement responses may not survive in their current form in later drafts of this document nor may
          individual listings of requirements; they may be subsumed into the flowing txt of the document.
        </p>
      </div>
      <div class="issue" data-number="72"></div>
      <div class="req-response">
        <p class="respTitle">RESPONSE FOR Req. 72</p>
        <p>

        </p>
      </div>
      <div class="issue" data-number="73"></div>
      <div class="req-response">
        <p class="respTitle">RESPONSE FOR Req. 73</p>
        <p>
          This requirement is addressed by suggesting how an Internet resource in general, rather than specifically a
          <code>dcat:Dataset</code> or <code>dcat:Distribution</code> should list profiles it implements. A DCAT-
          specific solution should not be any different from the general case.
        </p>
        <div class="note" title="">Profile definition and constraints on properties are not addressed here. See
          [[PROF-GUIDANCE]].</div>
        <p>
          This requirement is taken to mean "create a way to list the profiles implemented by a Internet resource for
          <em>humans</em> and <em>machines</em> to use". For the former (humans), the options are:
        </p>
        <ul>
          <li>
            discovery via HTML representation
            <ul>
              <li>see [[PROF-GUIDANCE]]</li>
              <li>an approach suggested is to provide an <em>alternate view</em> resource for the original
                resource located at <code>RESOURCE_URI + ?_view=alternates</code> which lists, at a minimum, the
                <em>profiles</em>, <em>media types</em> (formats) &amp; <em>languages</em> available, as per the
                <em>alternate views</em> guidance.
              </li>
            </ul>
          </li>
        </ul>
        <div class="issue" data-number="392"></div>
        <p>For the latter (machines):</p>
        <ul>
          <li>
            discovery via HTTP
            <ul>
              <li>see [[PROF-IETF]]</li>
              <li>HTTP mechanics are described that allow clients to negotiate with servers for profile listings</li>
            </ul>
          </li>
          <li>
            discovery via RDF graph
            <ul>
              <li>see [[PROF]]</li>
            </ul>
          </li>
        </ul>
        <div class="issue" data-number="393"></div>
      </div>
      <div class="issue" data-number="74"></div>
      <div class="req-response">
        <p class="respTitle">RESPONSE FOR Req. 74</p>
        <p>
          This requirement is the focus of the IETF RFC in the DXWG Family of Documents [[PROF-IETF]].
        </p>
        <p>
          In summary, a series of new HTTP headers are added to the HTTP specification allowing for HTTP negotiation
          via profile in a manner similar to negotiation via Media Type or Language.
        </p>
      </div>
      <div class="issue" data-number="86"></div>
      <div class="req-response">
        <p class="respTitle">RESPONSE FOR Req. 86</p>
        <p>

        </p>
      </div>
      <div class="issue" data-number="217"></div>
      <div class="req-response">
        <p class="respTitle">RESPONSE FOR Req. 217</p>
        <p>

        </p>
      </div>
      <div class="issue" data-number="261"></div>
      <div class="req-response">
        <p class="respTitle">RESPONSE FOR Req. 261</p>
        <p>

        </p>
      </div>
      <div class="issue" data-number="263"></div>
      <div class="req-response">
        <p class="respTitle">RESPONSE FOR Req. 263</p>
        <p>
          The IETF submission in the DXWG Family of Documents [[PROF-IETF]] does not address content negotiaiton by
          profile query param patterns: it is limited to HTTP specification-based negotiation only.
        </p>
        <p>
          Recommendations for content negotiation by profile via query param patterns (Query String Arguments) are
          given in the Profile Guidance [[PROF-GUIDANCE]] document where an API for this is defined.
        </p>
      </div>
      <div class="issue" data-number="264"></div>
      <div class="req-response">
        <p class="respTitle">RESPONSE FOR Req. 264</p>
        <p>

        </p>
      </div>
      <div class="issue" data-number="265"></div>
      <div class="req-response">
        <p class="respTitle">RESPONSE FOR Req. 265</p>
        <p>
          This requirement is met by [[PROF-IETF]].
        </p>
      </div>
      <div class="issue" data-number="266"></div>
      <div class="req-response">
        <p class="respTitle">RESPONSE FOR Req. 266</p>
        <p>

        </p>
      </div>
      <div class="issue" data-number="267"></div>
      <div class="req-response">
        <p class="respTitle">RESPONSE FOR Req. 267</p>
        <p>

        </p>
      </div>
      <div class="issue" data-number="284"></div>
      <div class="req-response">
        <p class="respTitle">RESPONSE FOR Req. 284</p>
        <p>
          <em>(assuming wording of "a profile must have an identifier")</em>
        </p>
        <p>
          Profiles must be identified by an HTTP URI.
        </p>
        <p>
          Short codes (tokens) for profiles that map to HTTP URIs for them may be used in systems that ensure the
          tokens map deterministically. This allows for the use of simple strings in places where URIs are impractical
          yet preserves the guarantee that every profile has an HTTP URI.
        </p>
      </div>
      <div class="issue" data-number="285"></div>
      <div class="req-response">
        <p class="respTitle">RESPONSE FOR Req. 285</p>
        <p>

        </p>
      </div>
      <div class="issue" data-number="286"></div>
      <div class="req-response">
        <p class="respTitle">RESPONSE FOR Req. 286</p>
        <p>

        </p>
      </div>
      <div class="issue" data-number="288"></div>
      <div class="req-response">
        <p class="respTitle">RESPONSE FOR Req. 288</p>
        <p>
          This requirement is met by [[PROF]].
        </p>
      </div>
      <div class="issue" data-number="289"></div>
      <div class="req-response">
        <p class="respTitle">RESPONSE FOR Req. 289</p>
        <p>
          This requirement is met by [[PROF-IETF]].
        </p>
      </div>
      <div class="issue" data-number="290"></div>
      <div class="req-response">
        <p class="respTitle">RESPONSE FOR Req. 290</p>
        <p>

        </p>
      </div>
    </section>
    <section id="issue-summary" class="appendix">
      <!-- A list of issues will magically appear here -->
    </section>
    <section id="extra-issues" class="appendix">
      <h2>Additional Issues</h2>
      <p><em>This section will be removed in a later version of this document.</em></p>
      <p>Additional Issues related to this document and not yet placed within it are listed at the:</p>
      <ul>
        <li><a href="https://github.com/w3c/dxwg/issues?utf8=%E2%9C%93&q=is%3Aissue+is%3Aopen+label%3Aprofile-negotiation+sort%3Acreated-asc+">GitHub Issues tracker for profile-negotiation</a></li>
      </ul>
    </section>
  </section>
  <script class="remove" src="config.js"></script>
  <script class="remove" src="https://www.w3.org/Tools/respec/respec-w3c-common"></script>
</body>
</html>
