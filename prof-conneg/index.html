<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" >
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport">
  <title>Content Negotiation by Profile</title>
  <link rel="stylesheet" type="text/css" href="extra.css">
</head>
<body class="h-entry" id="respecDocument">
  <section id="abstract">
    <h2>Abstract</h2>
    <p>
      This document describes how Internet clients may negotiate for content provided by servers according to
      <em>profiles</em>. This is distinct from negotiating by Media Type or Language: the <em>profile</em> is expected
      to specify the content of information returned, which may be a subset of what the responding server contains.
    </p>
    <p>
      For details about what a <em>profile</em> is, see the [[PROF-GUIDE]] recommendation published by the producers
      of this document.
    </p>
    <p>
      For the formal ontology describing <em>profile</em>s, their parts and relations to other profiles and
      specifications, see the [[PROF-ONT]] recommendation, also published by this document's publisher.
    </p>
  </section>
  <section id="sotd">
    <!-- The "Status of This Document" section is generated by config.js -->
    <section id="FamilyOfDocs">
      <h3>Overview of DXWG documents on profiles</h3>
      <p>
        This document is part of a set of documents on profiles, edited by the W3C Dataset Exchange Working Group (DXWG). 
	      Some of the documents are general while some are technology-specific:
      </p>
      <ul>
        <li>[[PROF-GUIDE]] the top-level general profiling guidance document giving an overview of all other documents</li>
        <li>[[PROF-ONT]] a document describing a formal ontology for describing objects related to profiles</li>
        <li><strong>[PROF-CONNEG] this document, including specific guidance on how to negotiate for Internet resource content using profiles</strong></li>
        <li>[[PROF-IETF]] an 
		<a href="http://www.ietf.org">Internet Engineering Task Force (<abbr title="Internet Engineering Task Force">IETF</abbr>)</a>
		<a href="http://www.ietf.org/standards/ids/">Internet-Draft</a>
		defining two Hypertext Transfer Protocol (HTTP) Headers
		for HTTP content negotiation by profile</li>
      </ul>
    </section>
  </section>
  <section id="introduction" class="informative">
    <h1>Introduction</h1>
    <p>
      Content delivered by dereferencing Internet identifiers has long been able to be negotiated for in different
      ways. When using the HTTP protocol [[RFC7230]], a client may set an <code>Accept</code> header specifying
      preferred Media Types which the server may or may not supply. Thus, resources available in different languages
      may be requested by setting an HTTP <code>Accept-Language</code> header. Until now, clients have not had a
      defined way to negotiate for content based on its adherence to an information model - a standard, a specification or
      a <a>profile</a> - and this document addresses this functionality.
    </p>
    <p>
      When online information about a resource adheres to one or more profiles, methods described here allow
      clients to list those profiles and request content according to one or more of them in order of preference.
      For example, information about an online book might adhere to the Dublin Core Terms [[DCTERMS]] metadata
      specification with each field of information, such as <em>title</em>, <em>description</em>, <em>author</em> etc.,
      being defined and formatted according to various Dublin Core elements (<code>dct:title</code>,
      <code>dct:description</code> &amp; <code>dct:creator</code>, respectively). Then, a request for the information about this
      book may ask for the list of profiles according to which the metadata is available, or it may ask specifically for a response adhering to the
      Dublin Core Terms. When a non-existent or unsupported profile is requested, a server returns default content.
    </p>
    <p>
      When selecting a content negotiation mechanism, an Internet client may use the HTTP protocol but it may also use
      other methods for providing instructions to a server,
      such as URI Query String Arguments (<abbr title="Query String Arguments">QSAs</abbr>).
      QSAs are
      established as useful for humans and machines for situations where negotiation via HTTP is not practical, such
      as when manually entering requests into web browsers. This document also provides guidance for both HTTP and non-HTTP methods
      of content negotiation and ensures they all adhere to a single functional specification, ensuring their functional equivalency.
    </p>
    <section id="compliance">
      <h3>Compliance with this Document</h3>
      <p>
        For the purpose of compliance, the normative sections of this document are
        <a href="#definitions">Section 2</a>,
        <a href="#abstractmodel">Section 5</a>,
        <a href="#realizations">Section 6</a>, and
        <a href="#testsuites">Section 7</a>.
      </p>
    </section>
    <section id="notationalconventions">
      <h3>Notational Conventions</h3>
      <p>
	The key words <em class="rfc2119">MAY</em>, <em class="rfc2119">MUST</em>, <em class="rfc2119">MUST NOT</em>,
	<em class="rfc2119">OPTIONAL</em>, <em class="rfc2119">SHALL</em>, <em class="rfc2119">SHALL NOT</em>,
	<em class="rfc2119">SHOULD</em>, <em class="rfc2119">SHOULD NOT</em>, <em class="rfc2119">RECOMMENDED</em>,
	and <em class="rfc2119">REQUIRED</em>,
        in this document are to be interpreted as described in [[RFC2119]].
      </p>
    </section>
  </section>
  <section id="definitions">
    <h2>Definitions</h2>
    <dl>
      <dt><dfn>specification</dfn></dt>
      <dd>
        <p>
          An act of identifying something precisely or of stating a precise requirement. - <a href="https://en.oxforddictionaries.com/definition/specification">Oxford English Dictionary</a>
        </p>
        <p>
          One form of a <em>specification</em> is a <em>standard</em> which is a "basis for comparison; a reference
          point against which other things can be evaluated" - [[DCTERMS]]
        </p>
      </dd>
      <dt><dfn>profile</dfn></dt>
      <dd>
        <p>
          A named set of constraints on one or more identified base <em>specifications</em>,
          including the identification of any implementing subclasses of datatypes,
          semantic interpretations, vocabularies, options and parameters of those base specifications
          necessary to accomplish a particular function.
        </p>
        <p>
          This definition includes what are often called "application profiles", "metadata application
          profiles", or "metadata profiles".
        </p>
        <p><em>Source: deliberations of the DXWG. See <a href="https://www.w3.org/2017/dxwg/wiki/ProfileContext">ProfileContext wiki page</a>.</em></p>
      </dd>
      <dt><dfn>client</dfn></dt>
      <dd>
        A program that establishes a connection to a server for the purpose of sending one or more HTTP requests
        [[RFC7230]]
      </dd>
      <dt><dfn>server</dfn></dt>
      <dd>
        A program that accepts connections in order to service HTTP requests by sending HTTP responses. [[RFC7230]]
      </dd>
      <dt><dfn>resource</dfn></dt>
      <dd>
        The entity that is identified by a URI. Familiar examples include an electronic
        document, an image, a source of information with a consistent purpose. [[RFC3986]]
      </dd>
      <dt><dfn>metadata</dfn></dt>
      <dd>Information that is supplied about a resource. [[RFC3986]]</dd>
      <dt><dfn>request</dfn></dt>
      <dd>A message sent over the Internet, from a <em>client</em> to a <em>server</em>, for a information about a <em>resource</em>. [[RFC7230]]</dd>
      <dt><dfn>response</dfn></dt>
      <dd>A message sent over the Internet, from a <em>server</em> to a <em>client</em> answering a <em>request</em> for information about a <em>resource</em> [[RFC7230]]</dd>
      <dt><dfn>token</dfn></dt>.
      <dd>A short name identifying something, in the context of this document a <a>profile</a></dd>.
    </dl>
    <div class="issue" data-number="378"></div>
    <div class="issue" data-number="537"></div>
  </section>
  <section id="motivation" class="informative">
    <h2>Motivation</h2>
    <p>
      In many cases, there are several ways to describe a resource within the scope of a single Media Type.
      For instance, XML documents, while conforming to the <code>text/xml</code> Media Type, may adhere to one of
      several DTDs or XML Schemas. RDF documents, with a choice of Media Type serializations such as
      <code>text/turtle</code>, <code>application/rdf+xml</code> and others, have a large number of vocabularies
      (classes and properties) available to use for their content's information model. When a client initiates a request
      for an Internet resource, such as an HTTP GET to retrieve a resource or an HTTP PUT to create or replace a resource, the client and server must have a standardized way to exchange information on how the transmitted resource
      will be structured according to DTDs, XML Schema, vocabularies or other standards, specifications or
      <em>profiles</em>. When using non-HTTP content negotiation, various methods such as URIs with Query String
      Arguments have been implemented previously,
      such as the
      <abbr title="Open Archives Initiative - Protocol for Metadata Harvesting">OAI-PMH</abbr> [[OAI-PMH]] and
      <abbr title="Open Geospatial Consortium">OGC</abbr>'s
      <abbr title="Catalogue Service for the Web">CSW</abbr> [[CSW]] protocols.
    </p>
    <p>
      This document describes content negotiation based on profiles using HTTP protocol. It introduces HTTP headers and
      non-HTTP methods, such as via QSAs, and defines a general QSA Application Programming Interface
      (<abbr title="Application Programming Interface">API</abbr>).
    </p>
  </section>
  <section id="relatedwork" class="informative">
    <h2>Related Work</h2>
    <p>
      What a <a>profile</a> is and how to create one is detailed in the [[PROF-GUIDE]] document created
      alongside this document, also by the Dataset Exchange Working Group (DXWG).
    </p>
    <p>
      The necessary standardization of the content-negotiation HTTP headers is done within the IETF. A first proposal
      for an <a href="https://profilenegotiation.github.io/I-D-Accept--Schema/I-D-accept-schema">Internet Draft
      for Negotiating Profiles in HTTP</a> [[PROF-IETF]] is available but has not yet been submitted to the IETF. The
      current version of the draft (-00) is expected to be completely re-written in course of the process and should
      not be seen as anything but work-in-progress.
    </p>
    <p class="issue" data-number="380">
	    The Internet-Draft for the registration of
	    <code>Accept-Profile</code> and <code>Content-Profile</code>
	    is currently work-in progress.
	    When that work is completed, the above text will be adjusted accordingly
	    or deleted.
    </p>
    <p class="issue" data-number="382">
	    Previous uses of <code>Accept-*</code> headers
	    or other HTTP headers for this use
	    will be listed and discussed here.
    </p>
    <p>
      Describing the parts of profiles and their relation to other profiles is done within the Profiles Ontology
      [[PROF-ONT]], also produced by the DXWG.
    </p>
    <div class="issue" data-number="383"></div>
    <div class="issue" data-number="516"></div>
    <div class="issue" data-number="384"></div>
    <div class="issue" data-number="514"></div>
  </section>
  <section id="abstractmodel">
    <h2>Abstract Model</h2>
    <p>
      This section describes an abstract conceptual model for content negotiation by profile, independent of any
      specific implementation - here termed realizations.
    </p>
    <section id="abstractmodelcontext">
      <h3>Context</h3>
      <p>
        All content negotiation takes place between a <a>client</a> and a <a>server</a> over the Internet with the
        former requesting a representation of a <a>resource</a> or <em>resource</em>'s <em>metadata</em> through a
        <em>request</em> and receiving it via a <em>response</em>. In some cases, a <em>server</em> may have to make a 
        <em>request</em> of a <em>client</em> and receive a <em>response</em>.
      </p>
      <p>
        An Internet <em>resource</em> may have many aspects over which a <em>client</em>/<em>server</em> pair of
        agents might negotiate for content. These aspects are to be treated independently so content negotiation for a 
        resource involving negotiation by profile and potentially multiple other aspects of a resource will not affect
        each other. For this reason, other than a directive to maintain independence, no further discussion of 
        negotiation by profile and the relations to other forms of negotiation are given. Specific realizations might
        require special handling of profile and other forms of negotiation.
      </p>
      <p>
        A <em>client</em> <em>request</em>ing the representation of a <em>resource</em> conforming to a <em>profile</em>
        MUST identify the <em>resource</em> by a Uniform Resource Identifier (URI) [[RFC3986]] and MUST
        identify a <em>profile</em> either by a URI or a <em>token</em> that unambiguously identifies the
        <em>profile</em> for the <em>server</em> within that <em>request</em>/<em>response</em> session.
      </p>
      <p>
        In this abstract model, we don't assume any specifics about <em>client</em>, <em>server</em>, <em>resource</em>,
        <em>metadata</em>, <em>request</em> or <em>response</em>.
      </p>
      <div class="issue" data-number="391"></div>
    </section>
    <section id="requestsandresonses">
      <h3>Requests and Responses</h3>
      <p>
        There are two main types of <em>request</em> that a <em>client</em> might make of a <em>server</em> regarding
        content negotiation by profile. A <em>client</em> wishing to negotiate for content via profile adhering to this
        specification MUST be able to implement these two request types.</p>
      <ol>
        <li>
          <strong>list profiles</strong><br />
          a <em>client</em> requests the list of URIs for <em>profile</em>s a <em>server</em> is able to deliver
          <em>resource</em> representations conforming to
        </li>
        <li>
          <strong>get resource by profile</strong>
          <br />a <em>client</em> requests a representation of the requested <em>resource</em> represented conforming
          to a particular <em>profile</em>
        </li>
      </ol>
      <p>
        A third <em>request</em> type is given that is expected not to apply to all realizations of this abstract model
        and not all clients adhering to this specification need implement it.
      </p>
      <ol start="3">
        <li>
          <strong>list profiles tokens</strong><br />
          a <em>client</em> requests the list of <em>token</em>s the <em>server</em> uses for <em>profile</em>s a
          <em>server</em> is able to deliver <em>resource</em> representations conforming to and their mapping to
          <em>profile</em> URIs
        </li>
      </ol>
      <p>
        A <em>server</em> adhering to this specification MUST respond to each request with the following
        <em>response</em>s. The first two types are required, handling the third depends on the realization environment.
      </p>
      <ol>
        <li>
          <strong>list profiles</strong><br />
          a <em>server</em> responds to a <em>client</em> with the list of <em>profile</em> URIs for the <em>profile</em>s it is able to
          deliver <em>resource</em> representations conforming to
        </li>
        <li>
          <strong>get resource by profile</strong><br />
          a <em>server</em> responds with either a specific <em>profile</em> for a <em>resource</em> conforming to a
          requested <em>profile</em> identified by the <em>client</em> or a default <em>profile</em>
        </li>
        <li>
          <strong>list profiles tokens</strong><br />
          a <em>server</em> responds the list of <em>profile </em> <em>token</em>s it is able to deliver
          <em>resource</em> representations conforming to and their mapping to <em>profile</em> URIs.
        </li>
      </ol>
      <p>More detailed descriptions of these requests and their responses are given next.</p>
      <section id="listprofiles">
        <h4>list profiles</h4>
        <p>
          A <em>client</em> wishes to know what <em>profile</em>s a <em>server</em> is able to deliver conformant
          representations of a <em>resource</em> for. This may need to be known either before a <em>request</em> for a 
          particular <em>resource</em> representation is made or perhaps after an initial <em>request</em> for a
          <em>resource</em> representation is made.
        </p>
        <p>
          The <strong>list profiles</strong> <em>request</em> MAY be an independent request or part of another 
          realization's request.
        </p>
        <p>
          The <strong>list profiles</strong> <em>request</em> MAY result in a <em>response</em> in one of a
          number of structures or formats provided the <em>profile</em>s representations of a <em>resource</em>
          conforming to are unambiguously identified either by URI or a <em>token</em> mappable to a URI.
        </p>
        <p>
          A <em>server</em> MUST NOT list <em>profile</em>s which <em>resource</em> representations conform to if
          it is unable to deliver those representations when presented with a <strong>get resource by profile</strong>
          <em>request</em>.
        </p>
      </section>
      <section id="getresourcebyprofile">
        <h4>get resource by profile</h4>
        <p>
          The most basic <em>request</em> of content negotiation by profile is for a <em>client</em> to <em>request</em>
          a representation of a <em>resource</em> that is claimed to conform to a <em>profile</em>.
        </p>
        <p>
          A <em>client</em> executing a <strong>get resource by profile</strong> <em>request</em> MUST
          identify the <em>profile</em> with either a URI or a token mappable to a URI.
        </p>
        <p>
          A <em>client</em> executing a <strong>get resource by profile</strong> MAY <em>request</em> a
          <em>resource</em> representation conforming to one of any number of <em>profile</em>s with its preference
          expressed in a some form of list ordering.
        </p>
      </section>
      <section id="listprofilestokens">
        <h4>list profiles tokens</h4>
        <p>
          A <em>client</em>/<em>server</em> pair of agents MAY refere to <em>profile</em>s by identifiers other
          than URIs, <em>token</em>, as long as both the <em>client</em> and <em>server</em> are able to
          deterministically map that token to a <em>profile</em>'s URI. This is due to the known requirement for
          <em>profile</em>s to be able to be referred to within other URIs, such as those of <em>resources</em> and other
          situations where referring to the <em>profile</em> itself by a URI is not possible.
        </p>
        <p>
          A <em>server</em> responding to a <strong>list profiles tokens</strong> <em>request</em> MUST provide
          token/URI mappings that list tokens and URIs, either of which can be used for <strong>get resource by
          profile</strong> <em>requests</em> within the same realization.
        </p>
      </section>
    </section>
  </section>
  <section id="realizations">
    <h2>Realizations</h2>
    <p>
      This section describes <em>realization</em>s of the abstract model in multiple implementation domains.
    </p>
    <section id="http">
      <h3>Hypertext Transfer Protocol</h3>
      <p>
        A realization of the Abstract Model using the Hypertext Transfer Protocol (HTTP) is presented here.
        This implementation is based on HTTP content negotiation and uses two new HTTP headers,
	      <code>Accept-Profile</code> and <code>Content-Profile</code>
	      that are to be defined in an upcoming Internet-Draft [[PROF-IETF]].
      </p>
      <p>
        Content negotiation by profile adds a further dimension to the already existing HTTP content
        negotiation dimensions, namely media type (<code>Accept</code>/<code>Content-Type</code>), encoding
        (<code>Accept-Encoding</code>/<code>Content-Encoding</code>) and language
        (<code>Accept-Language</code>/<code>Content-Language</code>).
      </p>
      <div class="issue" data-number="500"></div>
      <section id="listprofileshttp">
        <h3>list profiles</h3>
          <p>
            Listing profiles for a resource using HTTP can be done in two ways.
        </p>
	<section id="listprofileshttpoptions">
	  <h4>Using <code>HTTP OPTIONS</code></h4>
            <p class="issue" data-number="510">
		The use of <code>HTTP OPTIONS</code> is discouraged
		since the responses are not cacheable.
            </p>
	    <p>
	  	The first one is to issue an <code>OPTIONS</code> request against the resource.
		In this case a server implementing content negotiation by profile
		SHOULD return a <code>Content-Profile</code> header
		listing all profiles the requested resource conforms to.
	    </p>
	    <pre class="example nohighlight" title="Using HTTP OPTIONS to list available profiles" aria-busy="false" aria-live="polite">
OPTIONS /some/resource HTTP/1.1

---

HTTP/1.1 200 OK
Content-Profile: urn:example:profile:1;q=0.8,http://example.org/profiles/2;q=0.5
[More headers for this resource]
            </pre>
	</section>
	<section id="listprofilehttplink">
		<h4>Using a <code>HTTP Link</code> header field</h4>
        <p>
          The second way is to issue an <code>GET</code> or <code>HEAD</code> against the resource. In this 
          case a server implementing
          content negotiation by profile SHOULD return a HTTP <code>Link</code> header containing information about the
          default representation of that resource (i. e. the representation that will be returned after any
          content negotiation has been performed) and information about any alternate representations of that
          resource. The returned representation will be identified by <code>rel="self"</code>, other representations by
          <code>rel="alternate"</code>.
        </p>
        <p>As an example, consider the resource <code>http://example.org/a/resource</code>  available
          in the media types <code>application/xml</code>, <code>text/html</code> and <code>text/turtle</code>.
          The <code>text/html</code> representation has
          no profile, whereas the <code>application/xml</code> and <code>text/turtle</code> representations are
          both available in the profiles <code>urn:example:profile:1</code> and <code>urn:example:profile:2</code>.
        </p>
        <p>
          All representations of <code>/a/resource</code> have own content-location URLs which leaves us with the following matrix:
        </p>
        <table>
          <tr><th>Media type / profile</th><th>urn:example:profile:1</th><th>urn:example:profile:2</th></tr>
          <tr><th>text/html</th><td>http://example.org/a/resource.html</td><td>http://example.org/a/resource.html</td></tr>
          <tr><th>text/turtle</th><td>http://example.org/a/resource.prof1.ttl</td><td>http://example.org/a/resource.prof2.ttl</td></tr>
          <tr><th>application/xml</th><td>http://example.org/a/resource.prof1.xml</td><td>http://example.org/a/resource.prof2.xml</td></tr>
        </table>
        <p>
          Assuming that a request without an <code>Accept-Profile</code> header per default delivers content conforming to
          <code>urn:example:profile:1</code> a request/response pair would look as follows:
        </p>
        <pre class="example nohighlight" aria-busy="false" aria-live="polite" title="Using a Link-header to point list available profiles">
HEAD /a/resource HTTP/1.1
Accept: text/turtle
[more request headers]

---

HTTP/1.1 200 OK
Content-Type: text/turtle
Content-Location: http://example.org/a/resource.prof1.ttl
Content-Profile: urn:example:profile:1
Link: &lt;http://example.org/a/resource.prof1.ttl&gt;; rel="self"; type="text/turtle"; profile="urn:example:profile:1",
  &lt;http://example.org/a/resource.prof2.ttl&gt;; rel="alternate"; type="text/turtle"; profile="urn:example:profile:2",
  &lt;http://example.org/a/resource.prof1.xml&gt;; rel="alternate"; type="application/xml"; profile="urn:example:profile:1",
  &lt;http://example.org/a/resource.prof2.xml&gt;; rel="alternate"; type="application/xml"; profile="urn:example:profile:2",
  &lt;http://example.org/a/resource.html&gt;; rel="alternate"; type="text/html"
[more response headers]
          </pre>
          <div class="issue" data-number="501"></div>
      </section>
       </section>
      <section id="getresourcebyprofilehttp">
        <h3>get resource by profile</h3>
        <p>
          	Getting a resource representation conforming to a specific profile is done
		by issuing an <code>HTTP GET</code> request against the resource
		and specifying the desired profile URI in an <code>Accept-Profile</code> header.
          	It is possible to specify a range of acceptable profile URIs
		and also to indicate preferences by using quality indicators (q-values).
        </p>
        <pre class="example nohighlight" aria-busy="false" aria-live="polite" title="Requesting a representation conforming to a specific profile using HTTP headers">
GET /a/resource HTTP/1.1
Accept: text/turtle;q=0.8, application/xml;q=0.5
Accept-Profile: urn:example:profile:1;q=1.0,urn:example:profile:2;q=0.6
[more request headers]

---

HTTP/1.1 200 OK
Content-Type: text/turtle
Content-Profile: urn:example:profile:1
[more response headers]
        </pre>
        <p>
          Having performed content negotiation and returning a resource representation, it is RECOMMENDED
          that the server also include a Link header indicating the availability of alternate resources
          encoded in other media types and conforming to other profiles, as described above.
        </p>
      </section>
      <section id="listprofilestokenshttp">
        <h3>list profiles tokens</h3>
        <p>
          Currently, there is no proposed way to implement this function using HTTP.
        </p>
      </section>
    </section>
    <section id="qsa">
      <h2>Query String Arguments</h2>
	    <div class="issue" data-number="511"></div>
      <div class="issue" data-number="538"></div>
      <p>
	      A Query String Argument (QSA) realization of the <a href="#abstractmodel">Abstract Model</a>
	      is presented here. Unlike the HTTP realization,
 		which is the subject of an independent document [[PROF-IETF]],
	      this realization is fully specified here
	      and this document is considered normative for the QSA realization.
	      This realization does not preclude other QSA specifications for profile and content negotiation.
      </p>
      <p>
        A query string is a part of a URI which assigns values to specified parameters. QSAs are commonly used within
        web browsers by humans and in other <em>client</em>/<em>server</em> situations to deliver extra information to a
        <em>server</em>.
      </p>
      <p><strong><em>Key naming</em></strong></p>
      <p>
        When content negotiation by profile is to take place using QSAs, the <em>request</em>s and <em>response</em>s
        of the <a href="#abstractmodel">Abstract Model</a> MUST be implemented.
	      However there is some flexibility in how this may be done:
	      QSA key/value pairs must be implemented but the specific key terms may be changed.
	      In this realization, <code>_profile</code> and <code>_mediatype</code> are used
	      to indicate a single or a list of
        preference-ordered profiles or Media types respectively with profiles or Media Types indicated by either URI or
        token.
      </p>
      <div class="note" title="Current use of tokens for negotiation by Media Type">
        <p>
          Currently, the convention in HTTP content negotiation by media type uses tokens for Media Types, such as
          <code>text/html</code> or <code>application/ld+json</code> with the tokens registered at
          <a href="http://www.iana.org/assignments/media-types">IANA's Media Types list</a>.
        </p>
        <p>
          There is no proposal yet to create a central register of profiles as this is thought by the authors to be
          un-sustainable in the long-term, given the likely numbers of profiles to be established.
        </p>
        <p>
          For this reason, the QSA realization allows either URIs or tokens for profiles to be used and it is expected,
          though not mandated here, that QSA realizations will also allow URIs or tokens for Media Types and other
          content negotiation dimensions, such as language. There are already several initiatives that have created URIs
          for Media Types based on the IANA register's tokens.
        </p>
      </div>
      <p><strong><em>Resource URI</em></strong></p>
      <p>
        Resource URIs for which QSA-based profile negotiation is taking place MUST NOT themselves be QSA values
        of other resource URIs in any QSA-based realization. Such mechanics may be used but must be transparent to the
        realization's <em>client</em> applications.
      </p>
      <pre class="example nohighlight" aria-busy="false" aria-live="polite" title="Resource URIs must not, themselves, be parameters of other URIs">
For the representation of Resource X, according to Profile Y, in Media Type Z:

NOT ALLOWED:
GET /single/endpoint?resource=http://example.org/resource/X&amp;_profile=Y&amp;_mediatype=Z HTTP/1.1

ALLOWED:
GET /resource/X?_profile=Y&_mediatype=Z HTTP/1.1
      </pre>
      <section id="listprofilesqsa">
        <h4>list profiles</h4>
        <p>
          A QSA with a fixed value MUST be supported by a <em>server</em> to allow a <em>client</em> to
          make a <strong>list profiles</strong> <em>request</em>.
        </p>
        <p>
          The QSA key/value pair <code>_profile=list</code> SHOULD be used however the <em>server</em> MAY
          make available an equivalent pair as long as this is discoverable. This is to cater for APIs that alreadly
          implement a similar function using QSA key/value pairs such as <code>_view=alternates</code>.
        </p>
        <p>
          The complete request for the <em>profile</em>s to which a <em>resource</em>'s representations conform can be
          communicated in a single URI like thus:
        </p>
        <pre class="example nohighlight" aria-busy="false" aria-live="polite" title="Requesting a list of profiles for a resource by QSA">
GET /a/resource?_profile=list HTTP/1.1
        </pre>
        <!--
        <p><code>RESOURCE_URI?_profile=list</code></p>
        <p>where</p>
        -->
        <p>
          where <code>/a/resource</code> is the URI of the resource for which the list of available profiles is
          requested
        </p>
        <p>
          A <em>client</em> making this <em>request</em> MAY negotiate for particular formats of the response by
          using a QSA equivalent to the HTTP <code>Accept</code> header to indicate a Media Type. A <em>server</em>
          SHOULD implement a <code>_mediatype</code> QSA for this but MAY implement an alternative, such
          as <code>_format</code> as long as this is dicoverable,
        </p>
        <p>An example <em>profile</em> listing for a <em>resource</em> in HTML would look like:
        </p>
        <!--<p><code>RESOURCE_URI?_profile=list&_mediatype=text/html</code></p>-->
        <pre class="example nohighlight" aria-busy="false" aria-live="polite" title="Requesting a list of profiles for a resource by QSA in HTML">
GET /a/resource?_profile=list&amp;_mediatype=text/html HTTP/1.1
        </pre>
      </section>
      <section id="getresourcebyprofileqsa">
        <h4>get resource by profile</h4>
        <div class="issue" title="To be completed"></div>

        <p><strong><em>Expressing profile preference</em></strong></p>
        <p>
          A <em>server</em> implementing <em>profile</em> listing for <em>resource</em>s SHOULD allow the
          requester to indicate preferences. This SHOULD be done by allowing the QSA indicating the desired
          profile, usually <code>_profile</code>, to have a comma-separated list as its value so, for a
          <em>client</em> desiring representations of <code>/a/resource</code> according to profiles with tokens
          <code>aaa</code>, <code>bbb</code> &amp; <code>ccc</code> we have:
        </p>
        <pre class="example nohighlight" aria-busy="false" aria-live="polite" title="Requesting a list of profiles for a resource by QSA in HTML">
  GET /a/resource?_profile=aaa,bbb,ccc HTTP/1.1
        </pre>
        <p>
          Servers MAY support any combination of profile URIs or tokens for this
		(e.g. <code>aaa,http://example.org/profile-x,bbb</code>).
		However, in this situation, profile URIs containing commas must escape them.
        </p>
        <p>
          Similarly, a <em>server</em> implementing multiple Media Type return formats for <em>profile</em> listing SHOULD
          allow a client to specify a preference order for Media Types and also for other dimensions of content
          negotiation, such as language. When using a QSA-only API, Media Type preferences (and language and others in a
          similar fashion) MAY be specified in a comma-separated list form, most preferred to least such that
          a client requesting profil
        </p>
      </section>
      <section id="listprofilestokensqsa">
        <h4>list profiles tokens</h4>
        <div class="issue" title="To be completed"></div>
      </section>
    </section>
  </section>
  <section id="testsuites">
    <h2>Test Suites</h2>
    <p>
      This section includes links to software tools to be used for testing the adherence of implementations to the realizations
      given in this document.
    </p>
    <dl>
      <dt>Apache JMeter</dt>
      <dd>
        <p>
          An <a href="http://jmeter.apache.org/">Apache JMeter</a> implementation of a test suite is maintained at:
          <a href="https://github.com/CSIRO-enviro-informatics/prof-conneg-jmeter-test-suite">
            https://github.com/CSIRO-enviro-informatics/prof-conneg-jmeter-test-suite
          </a>
        </p>
      </dd>
    </dl>
    <div class="issue" data-number="385"></div>
  </section>
  <section id="implementations" class="informative">
    <h2>Implementations</h2>
    <p>
      This section includes implementations of the realizations given in this document and their conformance test results. The tools
      used for conformance testing are listed in the section above.
    </p>
    <ul>
      <li>
        <a href="https://github.com/CSIRO-enviro-informatics/prof-conneg-conf-test-results">
          https://github.com/CSIRO-enviro-informatics/prof-conneg-conf-test-results
        </a>
      </li>
    </ul>
    <div class="issue" data-number="467"></div>
  </section>
  <section id="security_and_privacy" class="informative">
    <h2>Security and Privacy</h2>
    <p>
      The use of HTTP to negotiate and transport implies that all privacy and security issues
      that are relevant for that protocol are also relevant for profile negotiation. E. g.,
      information such as user agent, accept-headers, IP address etc. can potentially be used as
      identifying information, and particularly, the IP address adds information about geolocation
      and institutional membership. Apart from that, there are no known security or privacy impacts
      of this feature.
    </p>
    <p>
      For a more complete view of those issues, cf. the
      <a href="https://www.w3.org/2017/dxwg/wiki/CnegPrivacyAndSecurityQuestionnaire">Privacy and Security Questionnaire for this deliverable</a>.
    </p>
  </section>
  <section id="appendices" class="appendix">
    <h2>Appendices</h2>
    <section id="requirements">
      <h2>Requirements</h2>
      <p>
        This section lists, and then addresses, individual requirements that the Dataset Exchange Working Group
        considered important for content negotiation by profile.
      </p>
      <div class="note">
        <p>
          Responses to individual requirement Issues listed here are, at the time of the First Public Working Draft of
          this document, for demonstration only; to indicate the logic of answers to individual requirements.
        </p>
        <p>
          These requirement responses may not survive in their current form in later drafts of this document nor may
          individual listings of requirements; they may be subsumed into the flowing txt of the document.
        </p>
      </div>
      <div class="issue" data-number="72"></div>
      <div class="req-response">
        <p class="respTitle">RESPONSE FOR Req. 72</p>
        <p>

        </p>
      </div>
      <div class="issue" data-number="73"></div>
      <div class="req-response">
        <p class="respTitle">RESPONSE FOR Req. 73</p>
        <p>
          This requirement is addressed by suggesting how an Internet resource in general, rather than specifically a
          <code>dcat:Dataset</code> or <code>dcat:Distribution</code> should list profiles it implements. A DCAT-
          specific solution should not be any different from the general case.
        </p>
        <div class="note" title="">Profile definition and constraints on properties are not addressed here. See
          [[PROF-GUIDE]].</div>
        <p>
          This requirement is taken to mean "create a way to list the profiles implemented by a Internet resource for
          <em>humans</em> and <em>machines</em> to use". For the former (humans), the options are:
        </p>
        <ul>
          <li>
            discovery via HTML representation
            <ul>
              <li>see [[PROF-GUIDE]]</li>
              <li>an approach suggested is to provide an <em>alternate view</em> resource for the original
                resource located at <code>RESOURCE_URI + ?_view=alternates</code> which lists, at a minimum, the
                <em>profiles</em>, <em>media types</em> (formats) &amp; <em>languages</em> available, as per the
                <em>alternate views</em> guidance.
              </li>
            </ul>
          </li>
        </ul>
        <div class="issue" data-number="392"></div>
        <p>For the latter (machines):</p>
        <ul>
          <li>
            discovery via HTTP
            <ul>
              <li>see [[PROF-IETF]]</li>
              <li>HTTP mechanics are described that allow clients to negotiate with servers for profile listings</li>
            </ul>
          </li>
          <li>
            discovery via RDF graph
            <ul>
              <li>see [[PROF-ONT]]</li>
            </ul>
          </li>
        </ul>
        <div class="issue" data-number="393"></div>
      </div>
      <div class="issue" data-number="74"></div>
      <div class="req-response">
        <p class="respTitle">RESPONSE FOR Req. 74</p>
        <p>
          This requirement is the focus of the IETF RFC in the DXWG Family of Documents [[PROF-IETF]].
        </p>
        <p>
          In summary, a series of new HTTP headers are added to the HTTP specification allowing for HTTP negotiation
          via profile in a manner similar to negotiation via Media Type or Language.
        </p>
      </div>
      <div class="issue" data-number="86"></div>
      <div class="req-response">
        <p class="respTitle">RESPONSE FOR Req. 86</p>
        <p>

        </p>
      </div>
      <div class="issue" data-number="217"></div>
      <div class="req-response">
        <p class="respTitle">RESPONSE FOR Req. 217</p>
        <p>

        </p>
      </div>
      <div class="issue" data-number="261"></div>
      <div class="req-response">
        <p class="respTitle">RESPONSE FOR Req. 261</p>
        <p>

        </p>
      </div>
      <div class="issue" data-number="263"></div>
      <div class="req-response">
        <p class="respTitle">RESPONSE FOR Req. 263</p>
        <p>
          The IETF submission in the DXWG Family of Documents [[PROF-IETF]] does not address content negotiaiton by
          profile query param patterns: it is limited to HTTP specification-based negotiation only.
        </p>
        <p>
          Recommendations for content negotiation by profile via query param patterns (Query String Arguments) are
          given in the Profile Guidance [[PROF-GUIDE]] document where an API for this is defined.
        </p>
      </div>
      <div class="issue" data-number="264"></div>
      <div class="req-response">
        <p class="respTitle">RESPONSE FOR Req. 264</p>
        <p>

        </p>
      </div>
      <div class="issue" data-number="265"></div>
      <div class="req-response">
        <p class="respTitle">RESPONSE FOR Req. 265</p>
        <p>
          This requirement is met by [[PROF-IETF]].
        </p>
      </div>
      <div class="issue" data-number="266"></div>
      <div class="req-response">
        <p class="respTitle">RESPONSE FOR Req. 266</p>
        <p>

        </p>
      </div>
      <div class="issue" data-number="267"></div>
      <div class="req-response">
        <p class="respTitle">RESPONSE FOR Req. 267</p>
        <p>

        </p>
      </div>
      <div class="issue" data-number="284"></div>
      <div class="req-response">
        <p class="respTitle">RESPONSE FOR Req. 284</p>
        <p>
          <em>(assuming wording of "a profile must have an identifier")</em>
        </p>
        <p>
          Profiles must be identified by an HTTP URI.
        </p>
        <p>
          Short codes (tokens) for profiles that map to HTTP URIs for them may be used in systems that ensure the
          tokens map deterministically. This allows for the use of simple strings in places where URIs are impractical
          yet preserves the guarantee that every profile has an HTTP URI.
        </p>
      </div>
      <div class="issue" data-number="285"></div>
      <div class="req-response">
        <p class="respTitle">RESPONSE FOR Req. 285</p>
        <p>

        </p>
      </div>
      <div class="issue" data-number="286"></div>
      <div class="req-response">
        <p class="respTitle">RESPONSE FOR Req. 286</p>
        <p>

        </p>
      </div>
      <div class="issue" data-number="287"></div>
      <div class="req-response">
        <p class="respTitle">RESPONSE FOR Req. 287</p>
        <p>

        </p>
      </div>
      <div class="issue" data-number="288"></div>
      <div class="req-response">
        <p class="respTitle">RESPONSE FOR Req. 288</p>
        <p>
          This requirement is met by [[PROF-ONT]].
        </p>
      </div>
      <div class="issue" data-number="289"></div>
      <div class="req-response">
        <p class="respTitle">RESPONSE FOR Req. 289</p>
        <p>
          This requirement is met by [[PROF-IETF]].
        </p>
      </div>
      <div class="issue" data-number="290"></div>
      <div class="req-response">
        <p class="respTitle">RESPONSE FOR Req. 290</p>
        <p>

        </p>
      </div>
    </section>
    <section id="issue-summary" class="appendix">
      <!-- A list of issues will magically appear here -->
    </section>
    <section id="extra-issues" class="appendix">
      <h2>Additional Issues</h2>
      <p><em>This section will be removed in a later version of this document.</em></p>
      <p>Additional Issues related to this document and not yet placed within it are listed at the:</p>
      <ul>
        <li><a href="https://github.com/w3c/dxwg/issues?utf8=%E2%9C%93&q=is%3Aissue+is%3Aopen+label%3Aprofile-negotiation+sort%3Acreated-asc+">GitHub Issues tracker for profile-negotiation</a></li>
      </ul>
    </section>
  </section>
  <script class="remove" src="config.js"></script>
  <script class="remove" src="https://www.w3.org/Tools/respec/respec-w3c-common"></script>
</body>
</html>
